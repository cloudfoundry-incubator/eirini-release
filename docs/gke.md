
# GKE with certificates generated by LetsEncrypt

- [GKE with certificates generated by LetsEncrypt](#gke-with-certificates-generated-by-letsencrypt)
  - [Prerequisites](#prerequisites)
  - [Configure Ingress](#configure-ingress)
    - [Reserve static IP address](#reserve-static-ip-address)
    - [Configure DNS](#configure-dns)
    - [Create service account with right access](#create-service-account-with-right-access)
    - [Deploy NGINX ingress controller & cert manager](#deploy-nginx-ingress-controller--cert-manager)
    - [Create a certificate issuer](#create-a-certificate-issuer)
    - [Create certificates](#create-certificates)
  - [Values.yaml](#valuesyaml)
  - [Deploying UAA](#deploying-uaa)
    - [Get UAA certificates](#get-uaa-certificates)
    - [Deploy UAA](#deploy-uaa)
  - [Deploying SCF](#deploying-scf)
    - [Get CA certificate](#get-ca-certificate)
    - [Get certificates for Gorouter](#get-certificates-for-gorouter)
    - [Deploy SCF](#deploy-scf)
  - [Certificate rotation](#certificate-rotation)
  - [Misc](#misc)

## Prerequisites

Make the Eirini helm repository available to helm:

```bash
helm repo add eirini https://cloudfoundry-incubator.github.io/eirini-release
```

Make the Bits helm repository available to helm:

```bash
helm repo add bits https://cloudfoundry-incubator.github.io/bits-service-release/helm
```

## Configure Ingress

### Reserve static IP address

See [more](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-external-ip-address)

*Note*: After you create the static ip you may notice that it is not connected to
any backend. This is expected. Later on when we install the nginx ingress
controller it will automatically create a backend and attach the static ip to
it.

### Configure DNS

Create a DNS zone in GKE and add the following A records:

- `<environment>.<zone>: <static-ip-address>`
- `*.<environment>.<zone>: <static-ip-address>`
- `uaa.<environment>.<zone>: <static-ip-address>`
- `*.uaa.<environment>.<zone>: <static-ip-address>`

*Note*: It is easier to reuse an existing DNS zone if you happen to have one
configured. If you create a new zone you need to configure your domain to
use the google cloud nameservers that your zone is mapped to. These are listed
as an NS record in your cloud DNS zone. If you do not do this your domain will
not resolve to the static ip in the google cloud but will rather use the default
nameservers of your domain provider.

### Create service account with right access

In order to generate valid certificate your components need to be able to create TXT DNS records in your zone.
Create a gcloud Role with the following permissions:

```text
  dns.changes.create
  dns.changes.get
  dns.managedZones.list
  dns.resourceRecordSets.create
  dns.resourceRecordSets.delete
  dns.resourceRecordSets.list
  dns.resourceRecordSets.update
```

Create a gcloud service-account, attaching it to the Role that you created.

### Deploy NGINX ingress controller & cert manager

Deploy [Nginx ingress controller](https://hub.helm.sh/charts/stable/nginx-ingress) with the following properties:

```
helm install stable/nginx-ingress --set rbac.create=true,controller.service.loadBalancerIP=<static-ip-address>
```

Deploy [CertManager](https://hub.helm.sh/charts/jetstack/cert-manager).
The documentation below is valid only for cert-manager v0.11.

```
kubectl apply -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.11/deploy/manifests/00-crds.yaml --validate=false 
helm repo add jetstack https://charts.jetstack.io
helm install --namespace cert-manager jetstack/cert-manager --version v0.11.0
```

### Create a certificate issuer

Create a secret with service account key in cert-manager namespace:

```bash
# generate a private-key for the service-account
gcloud alpha iam service-accounts keys create --iam-account <service-account-id> private-key.json
DNS_SERVICE_ACCOUNT="$(cat private-key.json)"
kubectl create secret generic -n cert-manager <secret-name> --from-literal=service-account.json="$DNS_SERVICE_ACCOUNT"
```

This is required for DNS validation. See more
[in official documentation](https://docs.cert-manager.io/en/latest/tutorials/acme/dns-validation.html).

Now create the cluster issuer

```
kubectl apply -f https://raw.githubusercontent.com/cloudfoundry-incubator/eirini-ci/master/cert-manager/letsencrypt-dns-issuer.yaml
```
`
## Values.yaml

```yaml
bits:
  env:
    DOMAIN: <environment>.<zone>
  ingress:
    endpoint: <environment>.<zone>
    use: true
    annotations:
      cert-manager.io/cluster-issuer: "<lets-encrypt-issuer-name>"
      # use the following line instead if you are using regular issuer
      # cert-manager.io/issuer: "<lets-encrypt-issuer-name>"
  secrets:
    BITS_SERVICE_SECRET: $BITS_SECRET
    BITS_SERVICE_SIGNING_USER_PASSWORD: $BITS_SECRET
    BLOBSTORE_PASSWORD: $BITS_SECRET

  # use cert generated by cert manager
  useExistingSecret: true

env:
    DOMAIN: <environment>.<zone>

    UAA_HOST: uaa.<environment>.<zone>
    UAA_PORT: 443
    UAA_PUBLIC_PORT: 443

kube:
    storage_class:
      persistent: standard
      shared: standard
    auth: rbac

secrets:
    CLUSTER_ADMIN_PASSWORD: $CLUSTER_ADMIN_PASSWORD
    UAA_ADMIN_CLIENT_SECRET: $UAA_ADMIN_CLIENT_SECRET
    BLOBSTORE_PASSWORD: $BITS_SECRET

ingress:
  enabled: true
  annotations:
    "nginx.ingress.kubernetes.io/proxy-body-size": "100m"
    cert-manager.io/cluster-issuer: "<lets-encrypt-issuer-name>"
    # use the following line instead if you are using regular issuer
    # cert-manager.io/issuer: "<lets-encrypt-issuer-name>"

eirini:
  opi:
    use_registry_ingress: true
    ingress_endpoint: <environment>.<zone>

  secrets:
    BLOBSTORE_PASSWORD: $BITS_SECRET
```

## Deploy UAA

```bash
  helm upgrade --install "uaa" \
    "uaa" \
    --namespace "uaa" \
    --values your-values.yaml
```

## Deploying SCF

### Get CA certificate

Some components validate the CA certificate for the UAA endpoint. You can get LetsEncrypt CA certificate for UAA running the following command:

```bash
    ROOT_CA="$(curl -s https://letsencrypt.org/certs/isrgrootx1.pem.txt)"
    INTERMEDIATE_CA="$(curl -s https://letsencrypt.org/certs/letsencryptauthorityx3.pem.txt)"
    CA_CERT="${ROOT_CA}

${INTERMEDIATE_CA}"
```

For more information about LetsEncrypt chain of trust see [here](https://letsencrypt.org/certificates/).

### Deploy SCF

```bash
  helm upgrade --install "scf" \
    cf \
    --namespace "scf" \
    --values your-values.yaml \
    --set "secrets.UAA_CA_CERT=${CA_CERT}"
```

## Certificate rotation

Bits certificate is rotated automatically by cert-manager and is picked up by Nginx Ingress controller.
Cert-manager will rotate certificates in Kubrenetes secrets, but you will have to copy them to the SCF secrets.
You can do this by upgrading UAA and SCF periodically.

## Misc

We recommend using Terraform to automate GKE cluster creation. You can check Eirini CI Terraform file [here](https://raw.githubusercontent.com/cloudfoundry-incubator/eirini-ci/master/gke-cluster/terraform.tf)
